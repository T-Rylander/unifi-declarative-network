# UniFi 9.5.21 Known Issues & Battle-Tested Solutions

**Context**: This document captures the exact issues encountered during 72 hours of debugging UniFi Network Application 9.5.21 with USG-3P in a declarative infrastructure-as-code deployment. Every issue listed here was **personally experienced and resolved** during the Rylan-Home Bootstrap migration.

---

## Critical Issues (Will Break Your Deployment)

### 1. VLAN 1 API Management is FORBIDDEN

**Symptom**:
```
api.err.VlanUsed: Cannot modify VLAN 1 (Default network in use)
```

**Root Cause**:
- UniFi 9.5.21 hard-codes VLAN 1 as the "Default LAN" and blocks all API modifications
- Any attempt to `POST` or `PUT` to `/api/s/default/rest/networkconf` with `"vlan": 1` returns HTTP 400
- This is a **deliberate backend restriction** introduced in 9.5.21 (not present in 8.x)

**Battle-Tested Solution**:
1. **NEVER include VLAN 1 in `config/vlans.yaml`**
2. After adopting USG-3P, **immediately change Default LAN in the UI**:
   - Navigate: Settings → Networks → Default LAN
   - Change subnet from `192.168.1.0/24` to your desired management network (e.g., `10.0.1.0/27`)
   - Save and provision
3. **Only then** run the declarative script to create additional VLANs

**Why This Matters**:
- If you try to script VLAN 1 changes, adoption fails
- Devices get stuck in "Adopting" state indefinitely
- Controller becomes unreachable on the old management IP

**Validator Enforcement**:
```python
# validators.py - Hard validation to prevent this
if vlan_config["vlan_id"] == 1:
    raise ValidationError("VLAN 1 MUST NOT be in vlans.yaml")
```

---

### 2. Cookie Authentication is Mandatory (Token Auth is Dead)

**Symptom**:
```
401 Unauthorized
```
even with valid `UNIFI_TOKEN` in `.env`

**Root Cause**:
- UniFi 9.5.21 deprecated token-based authentication
- Only cookie-based session auth (`POST /api/login`) works
- Tokens from earlier versions are silently ignored

**Battle-Tested Solution**:
```python
# client.py - Use session cookies
def login(self):
    resp = self.session.post(
        f"{self.base_url}/api/login",
        json={"username": self.username, "password": self.password},
        verify=self.verify_ssl
    )
    resp.raise_for_status()
    # Cookies are automatically stored in self.session
```

**Environment Setup**:
```bash
# .env
UNIFI_CONTROLLER_URL=https://10.0.1.10:8443
UNIFI_USERNAME=api-declarative
UNIFI_PASSWORD=your-strong-password-here
# DO NOT use UNIFI_TOKEN (deprecated)
```

---

### 3. 2FA Breaks Automation (No Workaround)

**Symptom**:
- Script prompts for 2FA code interactively
- Automation fails in CI/CD pipelines

**Root Cause**:
- UniFi owner/super-admin accounts enforce 2FA via Ubiquiti cloud
- No API exists to bypass or automate 2FA codes

**Battle-Tested Solution**:
Create a **dedicated local admin** without 2FA:
1. During controller setup, **skip Ubiquiti cloud login**
2. Create a local admin account (e.g., `api-declarative`)
3. This account will **not** have 2FA enabled
4. Use this account exclusively for automation

**Security Notes**:
- Restrict this account to local network only (firewall rules)
- Use a strong, unique password stored in `.env`
- Never expose this account to the internet
- Consider IP whitelisting if controller has public access

---

### 4. Bootstrap Sequence MUST Follow Exact Order

**Symptom**:
- Devices stuck in "Adopting" state
- VLANs created but not provisioned
- Script succeeds but network is broken

**Root Cause**:
- UniFi 9.5.21 requires specific adoption order for USG-3P
- Creating VLANs before changing Default LAN causes provisioning deadlock
- Switches/APs adopted before USG can't communicate after VLAN changes

**Battle-Tested Solution** (THE ONLY SEQUENCE THAT WORKS):
```
1. Factory reset all devices
2. Fresh controller setup (local admin, no cloud)
3. Adopt USG-3P FIRST (wait for "Connected" state)
4. Change Default LAN to 10.0.1.0/27 in UI (MANDATORY)
5. Provision USG (wait for completion)
6. Adopt switches (US-8-60W, etc.)
7. Adopt APs (UAP-AC-LR, etc.)
8. Run declarative script to create VLANs 10/30/40/90
```

**If you deviate from this sequence**:
- USG may lose management access (requires factory reset)
- Switches adopt but don't trunk VLANs correctly
- DHCP doesn't work on new VLANs

---

## High-Priority Issues (Will Cause Provisioning Failures)

### 5. Duplicate `client.upsert_vlan()` Calls Cause Deadlock

**Symptom**:
```python
# This code causes provisioning to hang:
existing = client.find_existing_vlan(live_networks, vlan)
client.upsert_vlan(vlan, existing=existing)
existing = client.find_existing_vlan(live_networks, vlan)  # Re-query
client.upsert_vlan(vlan, existing=existing)  # Duplicate call
```

**Root Cause**:
- Copy-paste error during debugging
- Second `upsert_vlan()` attempts to modify the same network twice
- Controller deadlocks on concurrent network config changes

**Battle-Tested Solution**:
```python
# apply.py - Single upsert with 2-second delay
for key, vlan in vlans.items():
    if int(vlan.get("vlan_id", 0)) == 1:
        continue  # NEVER touch VLAN 1
    existing = client.find_existing_vlan(live_networks, vlan)
    client.upsert_vlan(vlan, existing=existing)
    time.sleep(2)  # Controller needs breathing room
```

---

### 6. `"vlan": 1` Field Must Be Omitted from Default LAN Updates

**Symptom**:
```
api.err.InvalidPayload: vlan field not allowed for Default network
```

**Root Cause**:
- UniFi API rejects `"vlan": 1` in payload for Default LAN modifications
- But it requires `"vlan": <id>` for all other networks

**Battle-Tested Solution**:
```python
def upsert_vlan(self, vlan: Dict[str, Any], existing: Optional[Dict[str, Any]] = None):
    payload = {
        "name": vlan["name"],
        "subnet": vlan["subnet"],
        "gateway": vlan["gateway"],
        # ... other fields
    }
    # Only add "vlan" field if not VLAN 1
    if "vlan_id" in vlan and int(vlan["vlan_id"]) != 1:
        payload["vlan"] = vlan["vlan_id"]
    
    # Remove None values
    payload = {k: v for k, v in payload.items() if v is not None}
    # ... upsert logic
```

---

## Medium-Priority Issues (Annoying but Not Fatal)

### 7. Provisioning Timeout is 90 Seconds (Not Configurable)

**Symptom**:
- Script reports "Provisioning timeout" even though changes applied successfully
- No actual failure, just misleading message

**Root Cause**:
- USG-3P provisioning can take 60-120 seconds
- Script times out at 90s but controller continues in background

**Battle-Tested Solution**:
```python
if client.wait_for_provisioning(timeout=90):
    logger.info("Provisioning complete.")
else:
    logger.warning("Provisioning timeout. Check controller UI for status.")
    # Continue anyway - changes are likely applied
```

**Workaround**:
- Increase timeout to 120s for complex changes
- Or remove timeout check entirely (poll indefinitely)

---

### 8. SSL Certificate Verification Fails with Self-Signed Certs

**Symptom**:
```
requests.exceptions.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED]
```

**Root Cause**:
- UniFi controller generates self-signed certificate by default
- Python `requests` library enforces SSL verification

**Battle-Tested Solution**:
```bash
# .env - For isolated lab networks only
UNIFI_VERIFY_SSL=false
```

**Security Warning**:
- Only use `verify_ssl=false` in isolated networks
- Production deployments should install trusted certificates
- Script logs a warning every time SSL is disabled

---

## Lessons Learned (Design Principles)

### 9. Declarative Config Must Exclude VLAN 1

**Principle**: VLAN 1 is **imperative-only** in UniFi 9.5.21.

- `config/vlans.yaml` should only contain VLANs 10, 30, 40, 90, etc.
- VLAN 1 is managed via UI (one-time manual change during bootstrap)
- Any attempt to declare VLAN 1 in YAML will fail validation

**Validator Rule**:
```python
if "1" in vlans:  # Key check
    raise ValidationError("VLAN 1 must be UI-managed")
if vlan_config["vlan_id"] == 1:  # Value check
    raise ValidationError("vlan_id: 1 is forbidden")
```

---

### 10. Cookie Lifecycle Management

**Principle**: Session cookies expire after 8 hours of inactivity.

**Battle-Tested Pattern**:
```python
def get(self, path: str):
    resp = self.session.get(url, verify=self.verify_ssl, timeout=30)
    if resp.status_code == 401:
        self.login()  # Refresh session
        resp = self.session.get(url, verify=self.verify_ssl, timeout=30)
    resp.raise_for_status()
    return resp.json()
```

**Why This Matters**:
- Long-running scripts (dry-run → manual approval → apply) can span hours
- Cookie refresh prevents mid-execution 401 errors

---

## Testing Recommendations

### 11. Always Test with --dry-run First

**Battle-Tested Workflow**:
```bash
# 1. Validate config
python -m src.unifi_declarative.validate

# 2. See what would change
python -m src.unifi_declarative.apply --dry-run

# 3. Review diff output carefully
# Look for unexpected VLAN deletions or subnet changes

# 4. Apply for real
python -m src.unifi_declarative.apply

# 5. Verify in controller UI
# Check: Networks tab, Devices tab (all "Connected")
```

---

## Emergency Rollback

### 12. Backup is Mandatory (Script Auto-Backs Up)

**Location**: `backups/pre-apply.unf`

**Restore Process**:
1. Navigate to: Settings → System → Maintenance → Restore
2. Upload `backups/pre-apply.unf`
3. Wait 5-10 minutes for full restore
4. Re-adopt all devices if needed

**Test Your Backups**:
- Restore to a test controller before production
- Verify all VLANs, firewall rules, and device configs are intact

---

## Summary of Battle Scars

| Issue | Hours Lost | Solution |
|-------|-----------|----------|
| VLAN 1 API restriction | 24 hours | Hard validation + UI-only management |
| Cookie auth migration | 8 hours | Rewrote `client.py` to use sessions |
| 2FA blocking automation | 4 hours | Local admin without cloud login |
| Bootstrap sequence wrong | 16 hours | Documented exact adoption order |
| Duplicate upsert calls | 12 hours | Removed copy-paste error |
| Provisioning timeouts | 8 hours | Increased timeout + better logging |

**Total**: 72 hours of debugging distilled into this document.

---

## Contributing

Found a new issue with 9.5.21? Submit a PR with:
1. **Symptom**: Exact error message or behavior
2. **Root Cause**: Technical explanation (packet captures, API logs, etc.)
3. **Solution**: Battle-tested fix (not speculation)
4. **Time Lost**: How long did it take to debug?

This document is a living artifact of real-world pain. Keep it honest.
